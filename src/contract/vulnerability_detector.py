"""
漏洞模式检测器

检测智能合约中的已知漏洞模式：
- 字节码级别检测
- 函数签名分析
- 危险模式识别
"""

from dataclasses import dataclass
from typing import Dict, List, Optional, Callable, Any
import re

from src.contract.contract_model import (
    ContractInfo,
    BytecodeFeatures,
    Vulnerability,
    VulnerabilityType,
    VulnerabilitySeverity,
)


@dataclass
class VulnerabilityPattern:
    """漏洞模式定义"""
    vuln_type: VulnerabilityType
    severity: VulnerabilitySeverity
    title: str
    description: str
    recommendation: str
    detector: Callable[[ContractInfo, BytecodeFeatures], Optional[Vulnerability]]
    swc_id: Optional[str] = None
    cwe_id: Optional[str] = None


class VulnerabilityDetector:
    """漏洞检测器"""

    def __init__(self):
        self.patterns: List[VulnerabilityPattern] = []
        self._register_patterns()

    def _register_patterns(self):
        """注册所有漏洞检测模式"""

        # ===== 危险操作码检测 =====

        self.patterns.append(VulnerabilityPattern(
            vuln_type=VulnerabilityType.SELFDESTRUCT,
            severity=VulnerabilitySeverity.HIGH,
            title="Self-Destruct Capability",
            description="合约包含SELFDESTRUCT操作码，可被销毁并将余额发送到指定地址",
            recommendation="评估selfdestruct的必要性，确保仅授权地址可调用",
            detector=self._detect_selfdestruct,
            swc_id="SWC-106",
            cwe_id="CWE-284",
        ))

        self.patterns.append(VulnerabilityPattern(
            vuln_type=VulnerabilityType.DELEGATECALL_INJECTION,
            severity=VulnerabilitySeverity.CRITICAL,
            title="Delegatecall to User-Controlled Address",
            description="合约使用delegatecall，如果目标地址可被用户控制，可能导致合约被接管",
            recommendation="确保delegatecall目标地址不可被外部控制",
            detector=self._detect_delegatecall_risk,
            swc_id="SWC-112",
            cwe_id="CWE-829",
        ))

        # ===== 访问控制检测 =====

        self.patterns.append(VulnerabilityPattern(
            vuln_type=VulnerabilityType.TX_ORIGIN_AUTH,
            severity=VulnerabilitySeverity.MEDIUM,
            title="tx.origin Authentication",
            description="使用tx.origin进行身份验证，容易受到钓鱼攻击",
            recommendation="使用msg.sender替代tx.origin进行身份验证",
            detector=self._detect_tx_origin,
            swc_id="SWC-115",
            cwe_id="CWE-477",
        ))

        self.patterns.append(VulnerabilityPattern(
            vuln_type=VulnerabilityType.OWNER_PRIVILEGE,
            severity=VulnerabilitySeverity.MEDIUM,
            title="Owner Privileges",
            description="合约存在所有者特权函数，可能存在中心化风险",
            recommendation="评估权限设计，考虑多签或时间锁机制",
            detector=self._detect_owner_privilege,
            cwe_id="CWE-269",
        ))

        # ===== 代币安全检测 =====

        self.patterns.append(VulnerabilityPattern(
            vuln_type=VulnerabilityType.HIDDEN_MINT,
            severity=VulnerabilitySeverity.HIGH,
            title="Hidden Mint Function",
            description="代币合约存在铸币功能，所有者可无限增发代币",
            recommendation="如果无限增发非预期行为，应移除或限制铸币功能",
            detector=self._detect_hidden_mint,
            cwe_id="CWE-269",
        ))

        self.patterns.append(VulnerabilityPattern(
            vuln_type=VulnerabilityType.BLACKLIST_FUNCTION,
            severity=VulnerabilitySeverity.MEDIUM,
            title="Blacklist Capability",
            description="代币合约存在黑名单功能，所有者可阻止特定地址交易",
            recommendation="向用户披露黑名单功能的存在",
            detector=self._detect_blacklist,
            cwe_id="CWE-269",
        ))

        self.patterns.append(VulnerabilityPattern(
            vuln_type=VulnerabilityType.PAUSE_FUNCTION,
            severity=VulnerabilitySeverity.LOW,
            title="Pause Capability",
            description="合约存在暂停功能，所有者可暂停所有操作",
            recommendation="向用户披露暂停功能的存在",
            detector=self._detect_pause,
            cwe_id="CWE-269",
        ))

        self.patterns.append(VulnerabilityPattern(
            vuln_type=VulnerabilityType.HONEYPOT,
            severity=VulnerabilitySeverity.CRITICAL,
            title="Potential Honeypot",
            description="合约可能是蜜罐，存在阻止用户卖出的机制",
            recommendation="谨慎交互，深入分析合约代码",
            detector=self._detect_honeypot,
            cwe_id="CWE-693",
        ))

        # ===== 代理合约检测 =====

        self.patterns.append(VulnerabilityPattern(
            vuln_type=VulnerabilityType.UNINITIALIZED_PROXY,
            severity=VulnerabilitySeverity.CRITICAL,
            title="Uninitialized Proxy Risk",
            description="代理合约模式检测，需确保初始化正确执行",
            recommendation="确保代理合约的实现合约已正确初始化",
            detector=self._detect_proxy_risk,
            swc_id="SWC-109",
        ))

        # ===== 时间依赖检测 =====

        self.patterns.append(VulnerabilityPattern(
            vuln_type=VulnerabilityType.TIMESTAMP_DEPENDENCE,
            severity=VulnerabilitySeverity.LOW,
            title="Timestamp Dependence",
            description="合约依赖block.timestamp，可能被矿工轻微操纵",
            recommendation="避免将时间戳用于关键逻辑，或接受几分钟的误差",
            detector=self._detect_timestamp_dependence,
            swc_id="SWC-116",
            cwe_id="CWE-829",
        ))

        # ===== 闪电贷相关 =====

        self.patterns.append(VulnerabilityPattern(
            vuln_type=VulnerabilityType.FLASH_LOAN_VULNERABLE,
            severity=VulnerabilitySeverity.HIGH,
            title="Flash Loan Vulnerability Indicators",
            description="合约可能受闪电贷攻击影响，存在单交易价格操纵风险",
            recommendation="使用时间加权平均价格(TWAP)或其他抗操纵价格源",
            detector=self._detect_flash_loan_risk,
        ))

    def detect(self, contract: ContractInfo) -> List[Vulnerability]:
        """检测合约漏洞

        Args:
            contract: 合约信息

        Returns:
            发现的漏洞列表
        """
        vulnerabilities = []

        if not contract.features:
            return vulnerabilities

        for pattern in self.patterns:
            try:
                vuln = pattern.detector(contract, contract.features)
                if vuln:
                    # 补充漏洞信息
                    vuln.swc_id = pattern.swc_id
                    vuln.cwe_id = pattern.cwe_id
                    vulnerabilities.append(vuln)
            except Exception as e:
                # 检测器异常不应中断整体分析
                pass

        return vulnerabilities

    # ===== 检测器实现 =====

    def _detect_selfdestruct(
        self,
        contract: ContractInfo,
        features: BytecodeFeatures
    ) -> Optional[Vulnerability]:
        """检测SELFDESTRUCT"""
        if not features.has_selfdestruct:
            return None

        return Vulnerability(
            vuln_type=VulnerabilityType.SELFDESTRUCT,
            severity=VulnerabilitySeverity.HIGH,
            title="Self-Destruct Capability",
            description="合约包含SELFDESTRUCT操作码，合约可被销毁",
            recommendation="评估selfdestruct的必要性，确保仅授权地址可调用",
            details={
                "opcode_count": features.opcode_count.get("SELFDESTRUCT", 0),
            }
        )

    def _detect_delegatecall_risk(
        self,
        contract: ContractInfo,
        features: BytecodeFeatures
    ) -> Optional[Vulnerability]:
        """检测delegatecall风险"""
        if not features.has_delegatecall:
            return None

        # 如果是代理合约，delegatecall是预期行为
        if features.is_proxy or features.is_minimal_proxy:
            return Vulnerability(
                vuln_type=VulnerabilityType.DELEGATECALL_INJECTION,
                severity=VulnerabilitySeverity.INFO,
                title="Proxy Contract Detected",
                description="合约是代理模式，使用delegatecall转发调用",
                recommendation="确保实现合约的安全性",
                details={"is_proxy": True}
            )

        return Vulnerability(
            vuln_type=VulnerabilityType.DELEGATECALL_INJECTION,
            severity=VulnerabilitySeverity.HIGH,
            title="Delegatecall Usage",
            description="非代理合约使用delegatecall，需审查目标地址来源",
            recommendation="确保delegatecall目标地址不可被外部控制",
            details={"is_proxy": False}
        )

    def _detect_tx_origin(
        self,
        contract: ContractInfo,
        features: BytecodeFeatures
    ) -> Optional[Vulnerability]:
        """检测tx.origin使用"""
        # ORIGIN操作码对应tx.origin
        if features.opcode_count.get("ORIGIN", 0) == 0:
            return None

        return Vulnerability(
            vuln_type=VulnerabilityType.TX_ORIGIN_AUTH,
            severity=VulnerabilitySeverity.MEDIUM,
            title="tx.origin Usage Detected",
            description="合约使用tx.origin，可能用于身份验证",
            recommendation="避免使用tx.origin进行授权，使用msg.sender替代",
            details={
                "origin_count": features.opcode_count.get("ORIGIN", 0),
            }
        )

    def _detect_owner_privilege(
        self,
        contract: ContractInfo,
        features: BytecodeFeatures
    ) -> Optional[Vulnerability]:
        """检测所有者特权"""
        owner_selectors = {
            "0x715018a6": "renounceOwnership()",
            "0xf2fde38b": "transferOwnership(address)",
            "0x8da5cb5b": "owner()",
        }

        found = []
        for selector in features.function_selectors:
            if selector.lower() in owner_selectors:
                found.append(owner_selectors[selector.lower()])

        if not found:
            return None

        return Vulnerability(
            vuln_type=VulnerabilityType.OWNER_PRIVILEGE,
            severity=VulnerabilitySeverity.MEDIUM,
            title="Owner Privileges Detected",
            description=f"合约存在所有者特权函数: {', '.join(found)}",
            recommendation="评估权限设计，考虑多签或时间锁机制",
            details={"owner_functions": found}
        )

    def _detect_hidden_mint(
        self,
        contract: ContractInfo,
        features: BytecodeFeatures
    ) -> Optional[Vulnerability]:
        """检测隐藏铸币功能"""
        if not features.implements_erc20:
            return None

        mint_selectors = {
            "0x40c10f19": "mint(address,uint256)",
            "0xa0712d68": "mint(uint256)",
            "0x4e6ec247": "_mint(address,uint256)",
        }

        found = []
        for selector in features.function_selectors:
            if selector.lower() in mint_selectors:
                found.append(mint_selectors[selector.lower()])

        if not found:
            return None

        return Vulnerability(
            vuln_type=VulnerabilityType.HIDDEN_MINT,
            severity=VulnerabilitySeverity.HIGH,
            title="Mint Function Detected",
            description=f"代币合约存在铸币功能: {', '.join(found)}",
            recommendation="审查谁有权调用铸币功能，是否有上限限制",
            details={"mint_functions": found}
        )

    def _detect_blacklist(
        self,
        contract: ContractInfo,
        features: BytecodeFeatures
    ) -> Optional[Vulnerability]:
        """检测黑名单功能"""
        blacklist_selectors = {
            "0x16c38b3c": "setBlacklist(address,bool)",
            "0xf9f92be4": "blacklist(address)",
            "0xe4997dc5": "addBlackList(address)",
            "0x0ecb93c0": "removeBlackList(address)",
            "0xe47d6060": "isBlackListed(address)",
        }

        found = []
        for selector in features.function_selectors:
            if selector.lower() in blacklist_selectors:
                found.append(blacklist_selectors[selector.lower()])

        if not found:
            return None

        return Vulnerability(
            vuln_type=VulnerabilityType.BLACKLIST_FUNCTION,
            severity=VulnerabilitySeverity.MEDIUM,
            title="Blacklist Capability Detected",
            description=f"合约存在黑名单功能: {', '.join(found)}",
            recommendation="向用户披露黑名单功能的存在及使用条件",
            details={"blacklist_functions": found}
        )

    def _detect_pause(
        self,
        contract: ContractInfo,
        features: BytecodeFeatures
    ) -> Optional[Vulnerability]:
        """检测暂停功能"""
        pause_selectors = {
            "0x8456cb59": "pause()",
            "0x3f4ba83a": "unpause()",
            "0x5c975abb": "paused()",
        }

        found = []
        for selector in features.function_selectors:
            if selector.lower() in pause_selectors:
                found.append(pause_selectors[selector.lower()])

        if not found:
            return None

        return Vulnerability(
            vuln_type=VulnerabilityType.PAUSE_FUNCTION,
            severity=VulnerabilitySeverity.LOW,
            title="Pause Capability Detected",
            description=f"合约存在暂停功能: {', '.join(found)}",
            recommendation="向用户披露暂停功能的存在",
            details={"pause_functions": found}
        )

    def _detect_honeypot(
        self,
        contract: ContractInfo,
        features: BytecodeFeatures
    ) -> Optional[Vulnerability]:
        """检测蜜罐特征"""
        if not features.implements_erc20:
            return None

        honeypot_indicators = []

        # 指标1: 有黑名单但没有公开的检查函数
        blacklist_modify = {"0x16c38b3c", "0xf9f92be4", "0xe4997dc5"}
        blacklist_check = {"0xe47d6060"}
        has_blacklist_modify = any(s.lower() in blacklist_modify for s in features.function_selectors)
        has_blacklist_check = any(s.lower() in blacklist_check for s in features.function_selectors)

        if has_blacklist_modify and not has_blacklist_check:
            honeypot_indicators.append("hidden_blacklist")

        # 指标2: 有暂停但没有公开的paused()
        pause_modify = {"0x8456cb59", "0x3f4ba83a"}
        pause_check = {"0x5c975abb"}
        has_pause_modify = any(s.lower() in pause_modify for s in features.function_selectors)
        has_pause_check = any(s.lower() in pause_check for s in features.function_selectors)

        if has_pause_modify and not has_pause_check:
            honeypot_indicators.append("hidden_pause")

        # 指标3: 过多的存储写入操作（可能有复杂的限制逻辑）
        if features.storage_writes > 20 and features.bytecode_size < 5000:
            honeypot_indicators.append("complex_storage_for_size")

        if not honeypot_indicators:
            return None

        severity = VulnerabilitySeverity.HIGH if len(honeypot_indicators) > 1 else VulnerabilitySeverity.MEDIUM

        return Vulnerability(
            vuln_type=VulnerabilityType.HONEYPOT,
            severity=severity,
            title="Potential Honeypot Indicators",
            description=f"检测到蜜罐特征指标: {', '.join(honeypot_indicators)}",
            recommendation="谨慎交互，建议深入分析合约代码或进行测试交易",
            details={"indicators": honeypot_indicators}
        )

    def _detect_proxy_risk(
        self,
        contract: ContractInfo,
        features: BytecodeFeatures
    ) -> Optional[Vulnerability]:
        """检测代理合约风险"""
        if not features.is_proxy and not features.is_upgradeable:
            return None

        severity = VulnerabilitySeverity.INFO
        details = {"is_minimal_proxy": features.is_minimal_proxy}

        if features.is_upgradeable:
            severity = VulnerabilitySeverity.MEDIUM
            details["is_upgradeable"] = True

        return Vulnerability(
            vuln_type=VulnerabilityType.UNINITIALIZED_PROXY,
            severity=severity,
            title="Proxy Contract Pattern",
            description="合约使用代理模式，实际逻辑在实现合约中",
            recommendation="审查实现合约的安全性，确保初始化已正确执行",
            details=details
        )

    def _detect_timestamp_dependence(
        self,
        contract: ContractInfo,
        features: BytecodeFeatures
    ) -> Optional[Vulnerability]:
        """检测时间戳依赖"""
        timestamp_count = features.opcode_count.get("TIMESTAMP", 0)
        if timestamp_count == 0:
            return None

        # 如果只是用于日志等，影响较小
        severity = VulnerabilitySeverity.INFO
        if timestamp_count > 2:
            severity = VulnerabilitySeverity.LOW

        return Vulnerability(
            vuln_type=VulnerabilityType.TIMESTAMP_DEPENDENCE,
            severity=severity,
            title="Timestamp Dependence",
            description=f"合约使用block.timestamp ({timestamp_count}次)",
            recommendation="避免将时间戳用于关键随机数或精确时间逻辑",
            details={"timestamp_usage_count": timestamp_count}
        )

    def _detect_flash_loan_risk(
        self,
        contract: ContractInfo,
        features: BytecodeFeatures
    ) -> Optional[Vulnerability]:
        """检测闪电贷风险指标"""
        # 检测是否有外部价格依赖的特征
        flash_loan_indicators = []

        # 指标1: 存在STATICCALL（可能用于读取外部价格）
        if features.has_staticcall:
            flash_loan_indicators.append("external_call_for_data")

        # 指标2: DEX相关的函数选择器
        dex_selectors = {
            "0x0902f1ac": "getReserves()",
            "0xd21220a7": "token1()",
            "0x0dfe1681": "token0()",
        }
        for selector in features.function_selectors:
            if selector.lower() in dex_selectors:
                flash_loan_indicators.append("dex_price_query")
                break

        if not flash_loan_indicators:
            return None

        return Vulnerability(
            vuln_type=VulnerabilityType.FLASH_LOAN_VULNERABLE,
            severity=VulnerabilitySeverity.LOW,
            title="Flash Loan Risk Indicators",
            description=f"合约可能依赖外部价格数据: {', '.join(flash_loan_indicators)}",
            recommendation="如果依赖价格数据，建议使用TWAP或可信预言机",
            details={"indicators": flash_loan_indicators}
        )

    def get_pattern_count(self) -> int:
        """获取已注册的漏洞模式数量"""
        return len(self.patterns)

    def list_patterns(self) -> List[Dict[str, str]]:
        """列出所有漏洞模式"""
        return [
            {
                "type": p.vuln_type.value,
                "severity": p.severity.value,
                "title": p.title,
                "swc_id": p.swc_id or "N/A",
            }
            for p in self.patterns
        ]
